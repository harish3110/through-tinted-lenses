{
  
    
        "post0": {
            "title": "Getting started with Fastai V2",
            "content": ". I would like to start off these series of posts with an introduction to the fastai v2 library in the application of vision, which is arguably the most common application in the field, and definitely the most worked on. . . Importing the library and necessary modules . from utils import * from fastai2.vision.all import * %matplotlib inline . Note: The first line imports some helper function from utils.py as used in the fastbook repo which provides great visualization options. . . About the dataset . Let&#39;s start off with the Flowers dataset which is a common dataset for image classification tasks. The dataset is a collection of images of 102 different types of flowers which is nicely curated. The images of fairly reasonable size, shot in different angles and lighting conditions. In addition, there are categories that have large variations within the category and several very similar categories. . Here&#39;s a list of the 102 different categories of flowers in this dataset for you reference. . . Getting and exploring the dataset . Now that we have our arsenal setup and have an understanding on the data we are working. Let&#39;s download it and explore it. . About 90% of the work done by data scientist revolves around gathering data in a well defined manner. For simplicity let&#39;s start of with commnly available datasets. . Fastai library makes it extremely easy to get common well-know datasets and are stored in Amazon S3 buckets for fast retrieval and use. They&#39;re all stored in the URLs global constant. . flowers_link = URLs.FLOWERS flowers_link . &#39;https://s3.amazonaws.com/fast-ai-imageclas/oxford-102-flowers.tgz&#39; . path = untar_data(flowers_link) path.ls() . (#4) [Path(&#39;/home/jupyter/.fastai/data/oxford-102-flowers/jpg&#39;),Path(&#39;/home/jupyter/.fastai/data/oxford-102-flowers/train.txt&#39;),Path(&#39;/home/jupyter/.fastai/data/oxford-102-flowers/valid.txt&#39;),Path(&#39;/home/jupyter/.fastai/data/oxford-102-flowers/test.txt&#39;)] . The above response may appear like an datastructure similar to a list in Python, but it&#39;s a built-in fastai datastructure called &#39;L&#39;. You can think of it as a datastructure which is an amalgamation of lists and dicts in python. . The above output starts off with a tuple &#39;#4&#39; which indicates that the path has 4 sub-directories in it and then displays those directories as an array. . To see the directories better, let&#39;s just see the base path of the sub directories instead of the entire path. . Path.BASE_PATH = path path.ls() . (#4) [Path(&#39;jpg&#39;),Path(&#39;train.txt&#39;),Path(&#39;valid.txt&#39;),Path(&#39;test.txt&#39;)] . # !pip install tree !tree -d {path} . /home/jupyter/.fastai/data/oxford-102-flowers └── jpg 1 directory . Now we can clearly see that the directory has 1 folder and 3 .txt files: . jpg: A folder containing all the images of the dataset | txt files: 3 text files indicating train, test and validation. | . Let&#39;s look into the &#39;jpg&#39; folder: . Fastai provides an in-built function, get_image_files to get all image files in a folder as an &#39;L&#39; . files = get_image_files(path/&#39;jpg&#39;) files . (#8189) [Path(&#39;jpg/image_00449.jpg&#39;),Path(&#39;jpg/image_05363.jpg&#39;),Path(&#39;jpg/image_03934.jpg&#39;),Path(&#39;jpg/image_01496.jpg&#39;),Path(&#39;jpg/image_00897.jpg&#39;),Path(&#39;jpg/image_05944.jpg&#39;),Path(&#39;jpg/image_00647.jpg&#39;),Path(&#39;jpg/image_01510.jpg&#39;),Path(&#39;jpg/image_01634.jpg&#39;),Path(&#39;jpg/image_07025.jpg&#39;)...] . We can see that there are 8189 images in the dataset available to us. Let&#39;s look at one of the images. . img = PILImage.create(files[0]) img.show() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fb58bb9e490&gt; . Now let&#39;s look at the .txt files using pandas. Pandas is the go-to method for dealing with tabular structure in python and is an essential skill for all data scientist using python. . Pandas can read many formats of data such as csv, excel and even text files very easily and creates a pandas dataframe for manipulating it accordingly. . train = pd.read_csv(path/&#39;train.txt&#39;, header=None, sep=&#39; &#39;) train.head() #head displays the first 5 rows of the dataframe . 0 1 . 0 jpg/image_03860.jpg | 16 | . 1 jpg/image_06092.jpg | 13 | . 2 jpg/image_02400.jpg | 42 | . 3 jpg/image_02852.jpg | 55 | . 4 jpg/image_07710.jpg | 96 | . We can see that the file contains the image file name and its corresponding labels. So let&#39;s label the columns accordingly. . cols = [&#39;name&#39;, &#39;label&#39;] train.columns = cols train.head() . name label . 0 jpg/image_03860.jpg | 16 | . 1 jpg/image_06092.jpg | 13 | . 2 jpg/image_02400.jpg | 42 | . 3 jpg/image_02852.jpg | 55 | . 4 jpg/image_07710.jpg | 96 | . Now we have an organized structuring for our training files. Let&#39;s do the same to create a validation and test dataframe. . # validation df valid = pd.read_csv(path/&#39;valid.txt&#39;, sep=&quot; &quot;, names= cols ) # test df test = pd.read_csv(path/&#39;test.txt&#39;, sep=&quot; &quot;, names= cols ) . valid.head() . name label . 0 jpg/image_04467.jpg | 89 | . 1 jpg/image_07129.jpg | 44 | . 2 jpg/image_05166.jpg | 4 | . 3 jpg/image_07002.jpg | 34 | . 4 jpg/image_02007.jpg | 79 | . test.head() . name label . 0 jpg/image_06977.jpg | 34 | . 1 jpg/image_00800.jpg | 80 | . 2 jpg/image_05038.jpg | 58 | . 3 jpg/image_06759.jpg | 0 | . 4 jpg/image_01133.jpg | 45 | . Let&#39;s see the . print(len(train)) print(len(valid)) print(len(test)) . 1020 1020 6149 . We can see that we have a total of around 8000 labelled images to build our flower classifier. So let&#39;s utilize all the data available to build our model. To do so let&#39;s first merge the 3 dataframes in to one . df = pd.concat([train, valid, test], axis=0) df.head() . name label . 0 jpg/image_03860.jpg | 16 | . 1 jpg/image_06092.jpg | 13 | . 2 jpg/image_02400.jpg | 42 | . 3 jpg/image_02852.jpg | 55 | . 4 jpg/image_07710.jpg | 96 | . Let&#39;s now save this dataframe as a csv file for ease of access later on . df.to_csv(&#39;df.csv&#39;) . By looking at the above dataframe we can see that the images and numerically labelled by the creators of the datset, probably for easier mapping. This would make visualization pretty bad since we won&#39;t what flower we are seeing in the end. So let&#39;s get the mpping of the labels to the numerical assignemnt given here. . If you look at the main source of the dataset, the labels are provided in a .mat file and would be quite cumbersome to fetch. Luckily enough JosephKJ did the labelling and generously made it available for us here. I downloaded the .txt file and will read it using pandas. . labels = pd.read_csv(&#39;labels.txt&#39;, header=None, names = [&#39;labels&#39;]) labels[&#39;labels&#39;] = labels[&#39;labels&#39;].apply(lambda x: x.replace(&quot;&#39;&quot;, &quot;&quot;)) labels.head() . labels . 0 pink primrose | . 1 hard-leaved pocket orchid | . 2 canterbury bells | . 3 sweet pea | . 4 english marigold | . Now creating labels dictionary where key is the number and value is the respective name of the flower. . labels_dict = dict(zip(list(range(len(labels))), labels[&#39;labels&#39;])) . Let&#39;s use the powerful pandas apply function again to map the numerical labels in df with the labels_dict . # Creating a new column &#39;class&#39; using the existing label of images df[&#39;class&#39;] = df[&#39;label&#39;].apply(lambda x: labels_dict[x]) df.head() . name label class . 0 jpg/image_03860.jpg | 16 | purple coneflower | . 1 jpg/image_06092.jpg | 13 | spear thistle | . 2 jpg/image_02400.jpg | 42 | sword lily | . 3 jpg/image_02852.jpg | 55 | bishop of llandaff | . 4 jpg/image_07710.jpg | 96 | mallow | . Now that we have arranged our data exactly as we want it, let&#39;s move ahead to model building using fastai library. . . The DataBlock API . We have our data structured well and exactly as we want. It&#39;s now time to feed it into the fastai library. This can be done using the DataBlocks API. . The DataBlocks API is the Fastai solution to simplifying the most time-consuming task in a data science pipeline, Data Preparation. It&#39;s easy to use, highly hackable and can be be used for a wide variety of data pertaining to applications such as vision, tabular and text. . This a much-needed addition mid-level API added to the fastai v2 where it makes it so much easy to load in data as needed for deep learning models. . def get_x(r): return path/r[&#39;name&#39;] def get_y(r): return r[&#39;class&#39;] dblock = DataBlock(blocks=(ImageBlock, CategoryBlock), splitter=RandomSplitter(seed=42), get_x= get_x, get_y= get_y, item_tfms = Resize(224)) dls = dblock.dataloaders(df) . Let&#39;s get a basic understanding of what&#39;s happening in the above code. Creating data which can be fed to a model requires two steps: . 1. Create a DataBlock: . A Datablock can be considered as a series of sequential functions all collated into one function. For people who have used scikit-learn, this can be considered similar to a pipeline. . The DataBlock API requires for mandatory fucntions in order to get the input data in the desired format for model building and training: . blocks: This is used to define the input and output of the model. In the above code the type of input i.e the independant variable are images and hence ImageBlock and the output, i.e dependant variable are categories of flowers and hence CategoryBlock. . | splitter: Splitters are used to divide our data into training and validation. This is of atmost importance because we don&#39;t want our model to train and memorize all the training images. We would like a subset of images to validate how good our model is doing. In this case we use a method that randomly splits data in train and validation. . | getters: Getters are used to get the independant and dependant variables in the right order. The two getters used are get_x and get_y. Here we defined get_x by grabbing the name of the image file from df and adding the path to it and we defined get_y by getting the class column from df. . | transforms: Transforms are used to perform data augmentation techniques on our input data either on the entire data(item_tfms) on the CPU or on the data passed as batches(batch_tfms) when passing it through the architecture on the GPU. In this case we are just resizing all images to 224 which is mandatory as deep learning models need all our training images to be of the same size. . | . 2. Call the dataloaders method on your data: . A dataloaders is a method called on the DataBlock where we pass in our dataframe df to perform all the steps mentioned in the DataBlock which finally returns the data in the required format for modeling. . . Visualizing the data . Now that we have made our data ready and in the format to be ingested by the fastai librabry let&#39;s visualize our data. . We can use show_batch method from our dataloader created to visualize a batch of images and their labels . dls.show_batch() . . Building the model: . Let&#39;s build a deep learning model on our dataset using a Convolutional Neural Netwok(CNN) model. . Basic understanding of CNN&#39;s . Here&#39;s the general architecture of every CNN model . . Every CNN architecture consists of 4 parts: . Input layer: The input i.e the image dataset with &#39;n&#39; classes which are labeled properly on which our image classification model is built on. . | Feature extraction: This is the crux of the CNN model. It learns the various features of the classes in your data and how to distinguish between them during the training process. For instance, during the training process, if images of dogs are passed in, the initial layers learns simple features such as lines, edges, circles, but as we move to later layers the model, the model learns complex features like ears, nose and eyes of the dog. In machine language all these features are represented numerically and we refer to all these learnt features as parameters of the model. . | Classification: This part of the model is used to pool in the different features learnt and associate it with the corresponding class. Continuing our example of our dog, it could mean that we pool in the features learnt about the dog such as it&#39;s nose, eyes, tail etc. and associate it with the output label which is a dog. . | Output: This is the part that associates an input image to class as labelled in our training set. When a new image of say a dog is sent through a trained model, the output class of the model will get actiavted and indicate that the input image is that of a dog. . | . The entire structure of the model built above is referred to as a model architecture in deep learning. . Now, we can build a flowers classifier from scratch, but since we only have 8000 odd images for 102 different classes. We can safely say that we don&#39;t have enough data to build a nice model from scratch. . Instead let&#39;s use the biggest weapon in the deep learning arsenal available at our disposal, Transfer Learning. . . Transfer Learning . Transfer Learning is a method which uses the work done by other researchers who spend days on end to build appropriate architectures which train on large datasets for specific tasks. For instance, the ImageNet dataset which consists of 1.3 million images of various sizes around 500 pixels across, in 1000 categories, takes a few days to train. . The main idea is as follows, the ImageNet dataset has 1000 different everyday categories and the parameters and features it learns for each one of the categories can be applicable to make the building blocks of the flowers dataset we are working on. The initial feature extraction layers which learns simple features line lines, edges, circles etc. can be applicable to flowers as well and we can fine tune the final layers to distinguish between the different classes of flowers. . The final output layer(which is trained on 1000 categories) also needs to be removed and replaced with the 102 different classes of flowers. . . Defining the learner . In fastai, to build a model we use the cnn_learner class. We need to pass in the following details to the cnn_learner to train the model: . Dataloaders object: The dls dataloader we created according to how fastai needs the input data. | Model Architecture: This is the architecture we would like to use. Since we are making use of transfer learning, we&#39;ll use a pretrained model, in this case the famous resnet34 architecture. | Metrics: This is how you would like to keep track of your training progress. In this case we&#39;ll use accuracy, which indicates how well our model classifies all the classes in our data overall. | . learn = cnn_learner(dls, resnet34, metrics=accuracy) . Let&#39;s visualize the model architecture used i.e the resnet34 architecture . learn.summary() . Sequential (Input shape: [&#39;64 x 3 x 224 x 224&#39;]) ================================================================ Layer (type) Output Shape Param # Trainable ================================================================ Conv2d 64 x 64 x 112 x 112 9,408 False ________________________________________________________________ BatchNorm2d 64 x 64 x 112 x 112 128 True ________________________________________________________________ ReLU 64 x 64 x 112 x 112 0 False ________________________________________________________________ MaxPool2d 64 x 64 x 56 x 56 0 False ________________________________________________________________ Conv2d 64 x 64 x 56 x 56 36,864 False ________________________________________________________________ BatchNorm2d 64 x 64 x 56 x 56 128 True ________________________________________________________________ ReLU 64 x 64 x 56 x 56 0 False ________________________________________________________________ Conv2d 64 x 64 x 56 x 56 36,864 False ________________________________________________________________ BatchNorm2d 64 x 64 x 56 x 56 128 True ________________________________________________________________ Conv2d 64 x 64 x 56 x 56 36,864 False ________________________________________________________________ BatchNorm2d 64 x 64 x 56 x 56 128 True ________________________________________________________________ ReLU 64 x 64 x 56 x 56 0 False ________________________________________________________________ Conv2d 64 x 64 x 56 x 56 36,864 False ________________________________________________________________ BatchNorm2d 64 x 64 x 56 x 56 128 True ________________________________________________________________ Conv2d 64 x 64 x 56 x 56 36,864 False ________________________________________________________________ BatchNorm2d 64 x 64 x 56 x 56 128 True ________________________________________________________________ ReLU 64 x 64 x 56 x 56 0 False ________________________________________________________________ Conv2d 64 x 64 x 56 x 56 36,864 False ________________________________________________________________ BatchNorm2d 64 x 64 x 56 x 56 128 True ________________________________________________________________ Conv2d 64 x 128 x 28 x 28 73,728 False ________________________________________________________________ BatchNorm2d 64 x 128 x 28 x 28 256 True ________________________________________________________________ ReLU 64 x 128 x 28 x 28 0 False ________________________________________________________________ Conv2d 64 x 128 x 28 x 28 147,456 False ________________________________________________________________ BatchNorm2d 64 x 128 x 28 x 28 256 True ________________________________________________________________ Conv2d 64 x 128 x 28 x 28 8,192 False ________________________________________________________________ BatchNorm2d 64 x 128 x 28 x 28 256 True ________________________________________________________________ Conv2d 64 x 128 x 28 x 28 147,456 False ________________________________________________________________ BatchNorm2d 64 x 128 x 28 x 28 256 True ________________________________________________________________ ReLU 64 x 128 x 28 x 28 0 False ________________________________________________________________ Conv2d 64 x 128 x 28 x 28 147,456 False ________________________________________________________________ BatchNorm2d 64 x 128 x 28 x 28 256 True ________________________________________________________________ Conv2d 64 x 128 x 28 x 28 147,456 False ________________________________________________________________ BatchNorm2d 64 x 128 x 28 x 28 256 True ________________________________________________________________ ReLU 64 x 128 x 28 x 28 0 False ________________________________________________________________ Conv2d 64 x 128 x 28 x 28 147,456 False ________________________________________________________________ BatchNorm2d 64 x 128 x 28 x 28 256 True ________________________________________________________________ Conv2d 64 x 128 x 28 x 28 147,456 False ________________________________________________________________ BatchNorm2d 64 x 128 x 28 x 28 256 True ________________________________________________________________ ReLU 64 x 128 x 28 x 28 0 False ________________________________________________________________ Conv2d 64 x 128 x 28 x 28 147,456 False ________________________________________________________________ BatchNorm2d 64 x 128 x 28 x 28 256 True ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 294,912 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ ReLU 64 x 256 x 14 x 14 0 False ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 32,768 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ ReLU 64 x 256 x 14 x 14 0 False ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ ReLU 64 x 256 x 14 x 14 0 False ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ ReLU 64 x 256 x 14 x 14 0 False ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ ReLU 64 x 256 x 14 x 14 0 False ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ ReLU 64 x 256 x 14 x 14 0 False ________________________________________________________________ Conv2d 64 x 256 x 14 x 14 589,824 False ________________________________________________________________ BatchNorm2d 64 x 256 x 14 x 14 512 True ________________________________________________________________ Conv2d 64 x 512 x 7 x 7 1,179,648 False ________________________________________________________________ BatchNorm2d 64 x 512 x 7 x 7 1,024 True ________________________________________________________________ ReLU 64 x 512 x 7 x 7 0 False ________________________________________________________________ Conv2d 64 x 512 x 7 x 7 2,359,296 False ________________________________________________________________ BatchNorm2d 64 x 512 x 7 x 7 1,024 True ________________________________________________________________ Conv2d 64 x 512 x 7 x 7 131,072 False ________________________________________________________________ BatchNorm2d 64 x 512 x 7 x 7 1,024 True ________________________________________________________________ Conv2d 64 x 512 x 7 x 7 2,359,296 False ________________________________________________________________ BatchNorm2d 64 x 512 x 7 x 7 1,024 True ________________________________________________________________ ReLU 64 x 512 x 7 x 7 0 False ________________________________________________________________ Conv2d 64 x 512 x 7 x 7 2,359,296 False ________________________________________________________________ BatchNorm2d 64 x 512 x 7 x 7 1,024 True ________________________________________________________________ Conv2d 64 x 512 x 7 x 7 2,359,296 False ________________________________________________________________ BatchNorm2d 64 x 512 x 7 x 7 1,024 True ________________________________________________________________ ReLU 64 x 512 x 7 x 7 0 False ________________________________________________________________ Conv2d 64 x 512 x 7 x 7 2,359,296 False ________________________________________________________________ BatchNorm2d 64 x 512 x 7 x 7 1,024 True ________________________________________________________________ AdaptiveAvgPool2d 64 x 512 x 1 x 1 0 False ________________________________________________________________ AdaptiveMaxPool2d 64 x 512 x 1 x 1 0 False ________________________________________________________________ Flatten 64 x 1024 0 False ________________________________________________________________ BatchNorm1d 64 x 1024 2,048 True ________________________________________________________________ Dropout 64 x 1024 0 False ________________________________________________________________ Linear 64 x 512 524,288 True ________________________________________________________________ ReLU 64 x 512 0 False ________________________________________________________________ BatchNorm1d 64 x 512 1,024 True ________________________________________________________________ Dropout 64 x 512 0 False ________________________________________________________________ Linear 64 x 102 52,224 True ________________________________________________________________ Total params: 21,864,256 Total trainable params: 596,608 Total non-trainable params: 21,267,648 Optimizer used: &lt;function Adam at 0x7fb58deae170&gt; Loss function: FlattenedLoss of CrossEntropyLoss() Model frozen up to parameter group number 2 Callbacks: - TrainEvalCallback - Recorder - ProgressCallback . If you scroll down and read the summary in the end, you can see that there are a total of around 21 million parameters but only around 600k parameters are trainable. . This is because we have inherited a model trained extensively on the ImageNet dataset and are using the parameters learnt by that model to train our model on 102 classes of flowers. . Which means that the parameters learnt early on in the model to distinguish various objects are kept as is and the final layers are replaced to classify . Fine tuning pretrained model . Once we have created our learner based on a pretrained resnet34 model, lets train our learner on classifying the flowers. In fastai there&#39;s a leraner method specifically to quickly train a pretrained model called fine_tune. . fine_tune by default trains the head i.e the additional part to the model we added for our classification of 102 flowers for one eopch and then unfreezes the all the weights and optimizes the entire model including the weights in the strating phase. . So in the first epoch the model learns the 600k trainable parameters such that all 21 million parameters are trained roughly. In the consecutive 2 epochs it optimizes the all these weights specifically for the task in hand, i.e classifying 102 types of flowers. . learn.fine_tune(3) . epoch train_loss valid_loss accuracy time . 0 | 2.806532 | 0.673664 | 0.839951 | 00:34 | . epoch train_loss valid_loss accuracy time . 0 | 0.640522 | 0.267998 | 0.928528 | 00:32 | . 1 | 0.248703 | 0.152257 | 0.958461 | 00:32 | . 2 | 0.108091 | 0.139895 | 0.962737 | 00:32 | . We can see that by using the power of transfer learning, in 2 lines of code and 3 steps of training(epochs) which took about 30 seconds to train on small GPU we are able to build a flowers classifier which can classifiy between 102 types of flowers with greater than 96% accuracy! . This blows the original paper out of the water which came out in 2008 which used a non DL approach to tackle this problem and recieved an accuracy of about 72.8% . . But this isn&#39;t really a fair comparison. So if we compare our basic model the current leaderboard for the flowers-102 dataset we can see that the best accuracy on the entire dataset is about 99.7%. . So, this is a good starting point. This will act as our baseline model for future imporovements and experimentation in order to come closer to the current benchmark. . So lets save this model so that we can build on from here form next time. . learn.save(&#39;flowers-baseline&#39;) . We&#39;ll slowly build upon this and make this model better while learning more about building state-of-the-art models in the coming posts. . .",
            "url": "https://harish3110.github.io/through-tinted-lenses/fastai/classification/2020/03/29/Getting-started-with-Fastai-V2.html",
            "relUrl": "/fastai/classification/2020/03/29/Getting-started-with-Fastai-V2.html",
            "date": " • Mar 29, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Relearning how to learn, deep.",
            "content": "“The illiterate of the 21st century will not be those who cannot read and write, but those who cannot learn, unlearn, and relearn. ” ― Alvin Toffler — . Fact: Deep learning is hard! . I have a background in Electronics Engineering and having studied in the sub-continent, the amount of exposure to programming was virtually non-existent. Since graduating, I have slowly transitioned my way into the field of data science and machine learning by starting from scratch and building block after block, the necessary skills to call myself a data scientist, and land a job in the field. . Whenever I meet anyone from a non-ML background and tell them I’m a data scientist, their response is almost always the same. They nod in appreciation and say something like, “That’s the future!” and that “I’m on the right path!”. And if they’re a parent, holding to the Indian parent tag who takes the first opportunity to ‘help mold’ their child’s future, would introduce me to their son/daughter and ask me to discuss the field with them. Then they begin asking questions about the area like self-driving cars and other popular fields and finally land on to the million-dollar question “Is it difficult to become a deep learning engineer?”. To this, I always find myself lying and spout out of phrases like “it’s easy” and “anyone can do it”! Whereas the fact of the matter is that it entirely isn’t. . Being a self-learner, I learned how to code in Python, understood the fundamental concepts of data science and machine learning by following an array of popular MOOCs such as Coursera, Udacity, etc. as well as completed certifications from reputed colleges in India. It has been an incredible journey of learning, but it has not been easy! There is always a huge learning curve, and even after you complete a course or certification, there’s still that void of not having built anything meaningful. Every one of the courses makes a point of conveying the theory and underlying maths well but almost always fail at delivering to students the necessary tools to go ahead and build something meaningful. There’s still that next step(s) needed to be taken by the student to further the knowledge learned in the course. It’s not that it wasn’t possible; the amount of work required to put into it was not straightforward! . . Enter Fastai . I heard about Fastai and Jeremy Howard from my friends around version 1 of the course. I pushed it aside as one of the many courses suggested by people in the field due to their inherent allegiance to it having taken it. But over time, on Twitter, LinkedIn, and other sources, it had reached a point that I couldn’t not take a look at the course. So I finally succumbed to the pressure and started last year’s course. . . In less than two weeks, I binged watch through the entire part 1! The course was nothing like I had taken before! All the concepts explained intuitively in simple and easy manner and more importantly, everything taught was visualized through code and by building state-of-the-art models. Unfortunately, I couldn’t put in the necessary focus and didn’t follow through completely. But this time around I made sure to take a break in order to pursue the course this time around. . . Fact: Deep learning is hard . Fact: Deep learning is easy, if done right! . The main idea of the course and the library is to democratize this powerful tool of ‘Deep Learning’, such that it can be easily harnessed by people across all domains such that one apply the principles easily in their domain. . The course challenges the normal way of learning by following a top-down approach to understanding deep learning. In comparison to every other DL course under the sun, this course definitely makes the field easy to approach and most importantly it makes the implementation of the models very very easy. . Everything taught in this year’s course is again application-driven and closely follows the book written by the founders of fastai, Jeremy, and Sylvain. The only prerequisites needed to start with the course are high school math and intermediate coding skills in python, which, to be honest, can be picked up along the way(I’ll be sure to put up references for all in the end). This doesn’t mean that the course if geared for beginners, on the contrary veterans and beginners in the field, will have a lot discover in the course as the slowly peel through the nuances of the library, the ingenious implementations of various well-known libraries by incorporating clever tricks and insights learned through experimentation! . The lectures taught by Jeremy, the book as a manual to wade through the ‘frightening’ depths of deep learning, a fantastic community of like-minded and extremely helpful peers, is a complete package and the perfect recipe to learn. I couldn’t be more glad to be taking part in such an enriching learning experience, especially during these trying times, and despite it being virtual, I don’t believe it has lost a beat. . “What I hope is that lots of people will realize that state-of-the-art results of deep learning are something they can achieve even if they’re not a Stanford University deep learning PhD.” — Jeremy Howard . . My blog post series: . There’s definitely a self-centered motivation to write these blog posts. Following the advice by Rachel Thomas(co-founder of fast.ai) in her blog post, she encourages anyone on a learning path to put out blog posts in-order to maximize your learning. . But aside the learning advantages, I would like to do my best in helping guide people entering this field on how best to navigate the myriad resources in the field and hopefully impart some of the knowledge learned along my journey until now. . Being quarantined, I find this time to be the best opportunity to start my blog by delving into depths of this fantastic deep-learning library! . The course is currently private but will made public and free for all like all courses by fast.ai. Until then and hopefully even then, I hope I can help wade students through the mazes of Deep Learning, Fast.ai style! So let’s get into it! . In my upcoming blog post, i’ll provide an introduction to the fastai v2 library and build an image classifier on a well-known dataset. . .",
            "url": "https://harish3110.github.io/through-tinted-lenses/markdown/2020/03/28/Relearning-how-to-learn-deep.html",
            "relUrl": "/markdown/2020/03/28/Relearning-how-to-learn-deep.html",
            "date": " • Mar 28, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi there, Harish here! . . I am a data science and ML enthusiast trying to do my bit in the field, a technology evangelist, a bibliophile, and a deranged Liverpool fan! :) .",
          "url": "https://harish3110.github.io/through-tinted-lenses/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}